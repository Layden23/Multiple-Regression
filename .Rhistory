prompt=FALSE,
tidy=TRUE,
comment=NA,
message=FALSE,
warning=FALSE)
opts_knit$set(width=75)
pacman::p_load(readr,rstudioapi,ggplot2,cowplot,GGally,caret,dplyr,party)
products <- read_csv("datasets/existingproductattributes2017.csv")
newproducts <- read_csv("datasets/newproductattributes2017.csv")
plotprod <- products[, c(3:11, 13:18)]
View(plotprod)
for (i in names(plotprod[, -which(names(plotprod) == “Volume”)])) {
plotprod <- products[, c(3:11, 13:18)]
for (i in names(plotprod[, -which(names(plotprod) == “Volume”)])) {
plotprod <- products[, c(3:11, 13:18)]
for (i in names(plotprod[, -which(names(plotprod) == "Volume")])) {
print(ggplot(data = plotprod,
aes_string(x=i, y = plotprod$Volume))
+ geom_jitter(color = "darkred")
+ ylab("Volume")
)
}
names(plotprod)
sum(is.na(plotprod))
ProductType <- as.vector(products$ProductType)
products <- products[,-which(colnames(products) %in% "ProductType")]
#Correlation Matrix
corr_products <- cor(products)
#Colinearity:
findCorrelation(x = corr_products, cutoff = 0.80, names = T)
library(knitr)
library(rmdformats)
## Global options
options(max.print="75")
opts_chunk$set(echo=T,
cache=TRUE,
prompt=FALSE,
tidy=TRUE,
comment=NA,
message=FALSE,
warning=FALSE)
opts_knit$set(width=75)
pacman::p_load(readr,rstudioapi,ggplot2,cowplot,GGally,caret,dplyr,party)
products <- read_csv("datasets/existingproductattributes2017.csv")
newproducts <- read_csv("datasets/newproductattributes2017.csv")
plotprod <- products[, c(3:11, 13:18)]
for (i in names(plotprod[, -which(names(plotprod) == "Volume")])) {
print(ggplot(data = plotprod,
aes_string(x=i, y = plotprod$Volume))
+ geom_jitter(color = "darkred")
+ ylab("Volume")
)
}
#Check duplicated rows
sum(duplicated(products[,-which(names(products) %in% c("ProductNum","Price"))]))
#6 rows from the extended warranty are duplicated, so we'll remove them (but if we search manually we can see that here are 7 of them)
products <- products[-c(35:41),]
#Check NA
any(is.na(products))
for (i in c(1:ncol(products))){
print(paste(i,any(is.na(products[,i]))))
}
#There are missing values in the 12 column, which is "BestSellersRank".
#There are 15 missing values in Best Sellers Rank attribute, so we'll remove it.
products <- products[,-which(names(products) %in% "BestSellersRank")]
#Check outliers
boxplot(products$Volume)
#Cleaning outliers
products <- filter(products,
products$Volume < 7000)
anova_test <- aov(Volume ~ ProductType, data = products)
summary(anova_test)
ProductType <- as.vector(products$ProductType)
products <- products[,-which(colnames(products) %in% "ProductType")]
#Correlation Matrix
corr_products <- cor(products)
#Colinearity:
findCorrelation(x = corr_products, cutoff = 0.80, names = T)
pairwiseCor <- function(dataframe){
pairs <- combn(names(dataframe), 2, simplify=FALSE)
df <- data.frame(Variable1=rep(0,length(pairs)), Variable2=rep(0,length(pairs)),
AbsCor=rep(0,length(pairs)), Cor=rep(0,length(pairs)))
for(i in 1:length(pairs)){
df[i,1] <- pairs[[i]][1]
df[i,2] <- pairs[[i]][2]
df[i,3] <- round(abs(cor(dataframe[,pairs[[i]][1]], dataframe[,pairs[[i]][2]])),4)
df[i,4] <- round(cor(dataframe[,pairs[[i]][1]], dataframe[,pairs[[i]][2]]),4)
}
pairwiseCorDF <- df
pairwiseCorDF <- pairwiseCorDF[order(pairwiseCorDF$AbsCor, decreasing=TRUE),]
row.names(pairwiseCorDF) <- 1:length(pairs)
pairwiseCorDF <<- pairwiseCorDF
pairwiseCorDF
}
#x5StarReviews has perfect correlation, and we'll remove it. There's also colinearity between x4StarReviews and x3StarReviews, so we'll remove x3StarReviews. We do the same for x2StarReviews and x1StarReviews.
kable(pairwiseCor(products))
decisiontree <- ctree(Volume~.,data =
products[,-which(colnames(products) %in% c("x5StarReviews","x3StarReviews", "x1StarReviews"))],
controls = ctree_control(maxdepth = 3))
plot(decisiontree)
lm_model <- train(Volume~x4StarReviews + x3StarReviews + x2StarReviews + x1StarReviews,
products, method = "lm")
summary(lm_model)$coefficients
products$"Avg_WghtStar" <-  summary(lm_model)$coefficients[2]*products$x4StarReviews +
summary(lm_model)$coefficients[3]*products$x3StarReviews +
summary(lm_model)$coefficients[4]*products$x2StarReviews +
summary(lm_model)$coefficients[5]*products$x1StarReviews
#Decision Tree
avg_decisiontree <- ctree(Volume~.,data =
products[,-which(colnames(products) %in% c("x5StarReviews",
"x4StarReviews",
"x3StarReviews",
"x2StarReviews",
"x1StarReviews"))],
controls = ctree_control(maxdepth = 3))
plot(avg_decisiontree)
#Cross validation:
set.seed(69)
indexing <- createDataPartition(products$Volume, p = 0.75, list = F)
trainSet <- products[indexing,]
testSet <- products[-indexing,]
form <- c("Volume ~ x4StarReviews + PositiveServiceReview",
"Volume ~ Avg_WghtStar + PositiveServiceReview")
models <- c("rf","knn", "svmLinear", "svmRadial","glm")
combined <- c()
cnames <- vector()
for (i in form){
for (j in models) {
model <- train(formula(i), data = trainSet, method = j, tuneLength = 3, metric = "MAE")
predictions <- predict(model, testSet)
results <- postResample(predictions, testSet$Volume)
combined <- cbind(results, combined)
cnames <- c(paste(i,j),cnames)
}
}
colnames(combined) <-cnames
min(combined[3,] )
kable(combined)
#Best model for MAE is rf with variables= Avg_WghtStar and PositiveServiceReview
#We create the new avg_wght star variable
newproducts$"Avg_WghtStar" <-  summary(lm_model)$coefficients[2]*newproducts$x4StarReviews +
summary(lm_model)$coefficients[3]*newproducts$x3StarReviews +
summary(lm_model)$coefficients[4]*newproducts$x2StarReviews +
summary(lm_model)$coefficients[5]*newproducts$x1StarReviews
rf_model <- train(Volume ~ Avg_WghtStar + PositiveServiceReview,
trainSet, tuneLength = 3, metric = "MAE")
newproducts$Volume <- predict(rf_model,newproducts)
products$Volume[products$Volume == 0] <- 1
Volume <- as.numeric(products$Volume)
ex_preds <- as.numeric(predict(rf_model,products))
ae_errors <- as.numeric(abs(ex_preds - products$Volume))
re_errors <- as.numeric(ae_errors/products$Volume)
errors_df <- as.data.frame(cbind(Volume,ex_preds,ae_errors,re_errors))
errors_df$ProductType <- ProductType
errors_df$ProductNum <- products$ProductNum
ggplot(errors_df, aes(x = Volume, y = re_errors, color = ProductType)) + geom_jitter() + ylab("Relative error") + ggtitle("Relative error vs Volume")
ggplot(errors_df, aes(x = Volume, y = ae_errors, color = ProductType)) + geom_jitter() + ylab("Absolute error") + ggtitle("Absolute error vs Volume")
ccols <- c("volume"="#f04546","pred"="#3591d1")
ggplot(errors_df, aes()) +geom_jitter(aes(x=ProductNum, y = ex_preds, color = "pred")) + geom_jitter(aes(x=ProductNum, y = Volume, color = "volume" )) +
geom_smooth(aes(x=ProductNum, y = ex_preds, color = "pred"),method = "loess",
se = F) +
geom_smooth(aes(x=ProductNum, y = Volume, color = "volume"),method = "loess",
se = F) + ylab("Volume")
filtered <- newproducts[which(newproducts$ProductType == "PC"|newproducts$ProductType == "Laptop"|
newproducts$ProductType == "Netbook"|
newproducts$ProductType == "Smartphone"), ]
finalresults <- filtered[,which(colnames(filtered) %in% c("ProductType","ProductNum","Volume"))]
finalresults$Volume <- round(finalresults$Volume,0)
finalresults$Volume <- as.integer(finalresults$Volume)
kable(finalresults, caption = "Volume of the new products")
ProductType <- as.vector(products$ProductType)
products <- products[,-which(colnames(products) %in% "ProductType")]
#Correlation Matrix
corr_products <- cor(products)
#Colinearity:
findCorrelation(x = corr_products, cutoff = 0.80, names = T)
library(knitr)
library(rmdformats)
## Global options
options(max.print="75")
opts_chunk$set(echo=T,
cache=TRUE,
prompt=FALSE,
tidy=TRUE,
comment=NA,
message=FALSE,
warning=FALSE)
opts_knit$set(width=75)
pacman::p_load(readr,rstudioapi,ggplot2,cowplot,GGally,caret,dplyr,party)
products <- read_csv("datasets/existingproductattributes2017.csv")
newproducts <- read_csv("datasets/newproductattributes2017.csv")
plotprod <- products[, c(3:11, 13:18)]
for (i in names(plotprod[, -which(names(plotprod) == "Volume")])) {
print(ggplot(data = plotprod,
aes_string(x=i, y = plotprod$Volume))
+ geom_jitter(color = "darkred")
+ ylab("Volume")
)
}
#Check duplicated rows
sum(duplicated(products[,-which(names(products) %in% c("ProductNum","Price"))]))
#6 rows from the extended warranty are duplicated, so we'll remove them (but if we search manually we can see that here are 7 of them)
products <- products[-c(35:41),]
#Check NA
any(is.na(products))
for (i in c(1:ncol(products))){
print(paste(i,any(is.na(products[,i]))))
}
#There are missing values in the 12 column, which is "BestSellersRank".
#There are 15 missing values in Best Sellers Rank attribute, so we'll remove it.
products <- products[,-which(names(products) %in% "BestSellersRank")]
#Check outliers
boxplot(products$Volume)
#Cleaning outliers
products <- filter(products,
products$Volume < 7000)
anova_test <- aov(Volume ~ ProductType, data = products)
summary(anova_test)
ProductType <- as.vector(products$ProductType)
products <- products[,-which(colnames(products) %in% "ProductType")]
#Correlation Matrix
corr_products <- cor(products)
#Colinearity:
findCorrelation(x = corr_products, cutoff = 0.80, names = T)
pairwiseCor <- function(dataframe){
pairs <- combn(names(dataframe), 2, simplify=FALSE)
df <- data.frame(Variable1=rep(0,length(pairs)), Variable2=rep(0,length(pairs)),
AbsCor=rep(0,length(pairs)), Cor=rep(0,length(pairs)))
for(i in 1:length(pairs)){
df[i,1] <- pairs[[i]][1]
df[i,2] <- pairs[[i]][2]
df[i,3] <- round(abs(cor(dataframe[,pairs[[i]][1]], dataframe[,pairs[[i]][2]])),4)
df[i,4] <- round(cor(dataframe[,pairs[[i]][1]], dataframe[,pairs[[i]][2]]),4)
}
pairwiseCorDF <- df
pairwiseCorDF <- pairwiseCorDF[order(pairwiseCorDF$AbsCor, decreasing=TRUE),]
row.names(pairwiseCorDF) <- 1:length(pairs)
pairwiseCorDF <<- pairwiseCorDF
pairwiseCorDF
}
#x5StarReviews has perfect correlation, and we'll remove it. There's also colinearity between x4StarReviews and x3StarReviews, so we'll remove x3StarReviews. We do the same for x2StarReviews and x1StarReviews.
kable(head(pairwiseCor(products)))
decisiontree <- ctree(Volume~.,data =
products[,-which(colnames(products) %in% c("x5StarReviews","x3StarReviews", "x1StarReviews"))],
controls = ctree_control(maxdepth = 3))
plot(decisiontree)
lm_model <- train(Volume~x4StarReviews + x3StarReviews + x2StarReviews + x1StarReviews,
products, method = "lm")
summary(lm_model)$coefficients
products$"Avg_WghtStar" <-  summary(lm_model)$coefficients[2]*products$x4StarReviews +
summary(lm_model)$coefficients[3]*products$x3StarReviews +
summary(lm_model)$coefficients[4]*products$x2StarReviews +
summary(lm_model)$coefficients[5]*products$x1StarReviews
#Decision Tree
avg_decisiontree <- ctree(Volume~.,data =
products[,-which(colnames(products) %in% c("x5StarReviews",
"x4StarReviews",
"x3StarReviews",
"x2StarReviews",
"x1StarReviews"))],
controls = ctree_control(maxdepth = 3))
plot(avg_decisiontree)
#Cross validation:
set.seed(69)
indexing <- createDataPartition(products$Volume, p = 0.75, list = F)
trainSet <- products[indexing,]
testSet <- products[-indexing,]
form <- c("Volume ~ x4StarReviews + PositiveServiceReview",
"Volume ~ Avg_WghtStar + PositiveServiceReview")
models <- c("rf","knn", "svmLinear", "svmRadial","glm")
combined <- c()
cnames <- vector()
for (i in form){
for (j in models) {
model <- train(formula(i), data = trainSet, method = j, tuneLength = 3, metric = "MAE")
predictions <- predict(model, testSet)
results <- postResample(predictions, testSet$Volume)
combined <- cbind(results, combined)
cnames <- c(paste(i,j),cnames)
}
}
colnames(combined) <-cnames
min(combined[3,] )
kable(combined)
#Best model for MAE is rf with variables= Avg_WghtStar and PositiveServiceReview
#We create the new avg_wght star variable
newproducts$"Avg_WghtStar" <-  summary(lm_model)$coefficients[2]*newproducts$x4StarReviews +
summary(lm_model)$coefficients[3]*newproducts$x3StarReviews +
summary(lm_model)$coefficients[4]*newproducts$x2StarReviews +
summary(lm_model)$coefficients[5]*newproducts$x1StarReviews
rf_model <- train(Volume ~ Avg_WghtStar + PositiveServiceReview,
trainSet, tuneLength = 3, metric = "MAE")
newproducts$Volume <- predict(rf_model,newproducts)
products$Volume[products$Volume == 0] <- 1
Volume <- as.numeric(products$Volume)
ex_preds <- as.numeric(predict(rf_model,products))
ae_errors <- as.numeric(abs(ex_preds - products$Volume))
re_errors <- as.numeric(ae_errors/products$Volume)
errors_df <- as.data.frame(cbind(Volume,ex_preds,ae_errors,re_errors))
errors_df$ProductType <- ProductType
errors_df$ProductNum <- products$ProductNum
ggplot(errors_df, aes(x = Volume, y = re_errors, color = ProductType)) + geom_jitter() + ylab("Relative error") + ggtitle("Relative error vs Volume")
ggplot(errors_df, aes(x = Volume, y = ae_errors, color = ProductType)) + geom_jitter() + ylab("Absolute error") + ggtitle("Absolute error vs Volume")
ccols <- c("volume"="#f04546","pred"="#3591d1")
ggplot(errors_df, aes()) +geom_jitter(aes(x=ProductNum, y = ex_preds, color = "pred")) + geom_jitter(aes(x=ProductNum, y = Volume, color = "volume" )) +
geom_smooth(aes(x=ProductNum, y = ex_preds, color = "pred"),method = "loess",
se = F) +
geom_smooth(aes(x=ProductNum, y = Volume, color = "volume"),method = "loess",
se = F) + ylab("Volume")
filtered <- newproducts[which(newproducts$ProductType == "PC"|newproducts$ProductType == "Laptop"|
newproducts$ProductType == "Netbook"|
newproducts$ProductType == "Smartphone"), ]
finalresults <- filtered[,which(colnames(filtered) %in% c("ProductType","ProductNum","Volume"))]
finalresults$Volume <- round(finalresults$Volume,0)
finalresults$Volume <- as.integer(finalresults$Volume)
kable(finalresults, caption = "Volume of the new products")
#x5StarReviews has perfect correlation, and we'll remove it. There's also colinearity between x4StarReviews and x3StarReviews, so we'll remove x3StarReviews. We do the same for x2StarReviews and x1StarReviews.
pairw <- (pairwiseCor(products))
kable(pairw[10,])
kable(pairw[1:10,])
kable(pairw[1:20,])
ProductType <- as.vector(products$ProductType)
products <- products[,-which(colnames(products) %in% "ProductType")]
#Correlation Matrix
corr_products <- cor(products)
#Colinearity:
findCorrelation(x = corr_products, cutoff = 0.80, names = T)
#x5StarReviews has perfect correlation, and we'll remove it. There's also colinearity between x4StarReviews and x3StarReviews, so we'll remove x3StarReviews. We do the same for x2StarReviews and x1StarReviews.
pairw <- (pairwiseCor(products))
kable(pairw[1:14,])
#Check outliers
boxplot(products$Volume)$out
boxplot(products$Volume)$out
#Check outliers
boxplot(products$Volume)$out
####Import datasets####
pacman::p_load(readr,rstudioapi,ggplot2,cowplot,GGally,caret,dplyr,party)
current_path = getActiveDocumentContext()$path
setwd(dirname(current_path))
setwd("..")
rm(current_path)
products <- read_csv("datasets/existingproductattributes2017.csv")
newproducts <- read_csv("datasets/newproductattributes2017.csv")
set.seed(619)
#Check duplicated rows
sum(duplicated(products[,-which(names(products) %in% c("ProductNum","Price"))]))
#6 rows from the extended warranty are duplicated, so we'll remove them
for (i in c(1:ncol(products))){
a <- any(is.na(products[,i]))
if (a == T) {
products[-i]
}
}
#Check NA
any(is.na(products))
summary(products)
#There are missing values.
#There are 15 missing values in Best Sellers Rank attribute, so we'll remove it.
products <- products[,-which(names(products) %in% "BestSellersRank")]
#Check outliers
boxplot(products$Volume)$out
lm_model <- train(Volume~x4StarReviews + x3StarReviews + x2StarReviews + x1StarReviews,
products, method = "lm")
summary(lm_model)$coefficients
products$"Avg_WghtStar" <-  summary(lm_model)$coefficients[2]*products$x4StarReviews +
summary(lm_model)$coefficients[3]*products$x3StarReviews +
summary(lm_model)$coefficients[4]*products$x2StarReviews +
summary(lm_model)$coefficients[5]*products$x1StarReviews
pairw <- (pairwiseCor(products))
library(knitr)
library(rmdformats)
## Global options
options(max.print="75")
opts_chunk$set(echo=T,
cache=TRUE,
prompt=FALSE,
tidy=TRUE,
comment=NA,
message=FALSE,
warning=FALSE)
opts_knit$set(width=75)
pacman::p_load(readr,rstudioapi,ggplot2,cowplot,GGally,caret,dplyr,party)
products <- read_csv("datasets/existingproductattributes2017.csv")
newproducts <- read_csv("datasets/newproductattributes2017.csv")
plotprod <- products[, c(3:11, 13:18)]
for (i in names(plotprod[, -which(names(plotprod) == "Volume")])) {
print(ggplot(data = plotprod,
aes_string(x=i, y = plotprod$Volume))
+ geom_jitter(color = "darkred")
+ ylab("Volume")
)
}
#Check duplicated rows
sum(duplicated(products[,-which(names(products) %in% c("ProductNum","Price"))]))
#6 rows from the extended warranty are duplicated, so we'll remove them (but if we search manually we can see that here are 7 of them)
products <- products[-c(35:41),]
#Check NA
any(is.na(products))
for (i in c(1:ncol(products))){
print(paste(i,any(is.na(products[,i]))))
}
#There are missing values in the 12 column, which is "BestSellersRank".
#There are 15 missing values in Best Sellers Rank attribute, so we'll remove it.
products <- products[,-which(names(products) %in% "BestSellersRank")]
#Check outliers
boxplot(products$Volume)
#Cleaning outliers
products <- filter(products,
products$Volume < 7000)
anova_test <- aov(Volume ~ ProductType, data = products)
summary(anova_test)
ProductType <- as.vector(products$ProductType)
products <- products[,-which(colnames(products) %in% "ProductType")]
#Correlation Matrix
corr_products <- cor(products)
#Colinearity:
findCorrelation(x = corr_products, cutoff = 0.80, names = T)
pairwiseCor <- function(dataframe){
pairs <- combn(names(dataframe), 2, simplify=FALSE)
df <- data.frame(Variable1=rep(0,length(pairs)), Variable2=rep(0,length(pairs)),
AbsCor=rep(0,length(pairs)), Cor=rep(0,length(pairs)))
for(i in 1:length(pairs)){
df[i,1] <- pairs[[i]][1]
df[i,2] <- pairs[[i]][2]
df[i,3] <- round(abs(cor(dataframe[,pairs[[i]][1]], dataframe[,pairs[[i]][2]])),4)
df[i,4] <- round(cor(dataframe[,pairs[[i]][1]], dataframe[,pairs[[i]][2]]),4)
}
pairwiseCorDF <- df
pairwiseCorDF <- pairwiseCorDF[order(pairwiseCorDF$AbsCor, decreasing=TRUE),]
row.names(pairwiseCorDF) <- 1:length(pairs)
pairwiseCorDF <<- pairwiseCorDF
pairwiseCorDF
}
#x5StarReviews has perfect correlation, and we'll remove it. There's also colinearity between x4StarReviews and x3StarReviews, so we'll remove x3StarReviews. We do the same for x2StarReviews and x1StarReviews.
pairw <- (pairwiseCor(products))
kable(pairw[1:14,])
decisiontree <- ctree(Volume~.,data =
products[,-which(colnames(products) %in% c("x5StarReviews","x3StarReviews", "x1StarReviews"))],
controls = ctree_control(maxdepth = 3))
plot(decisiontree)
lm_model <- train(Volume~x4StarReviews + x3StarReviews + x2StarReviews + x1StarReviews,
products, method = "lm")
summary(lm_model)$coefficients
products$"Avg_WghtStar" <-  summary(lm_model)$coefficients[2]*products$x4StarReviews +
summary(lm_model)$coefficients[3]*products$x3StarReviews +
summary(lm_model)$coefficients[4]*products$x2StarReviews +
summary(lm_model)$coefficients[5]*products$x1StarReviews
pairw <- (pairwiseCor(products))
#Decision Tree
avg_decisiontree <- ctree(Volume~.,data =
products[,-which(colnames(products) %in% c("x5StarReviews",
"x4StarReviews",
"x3StarReviews",
"x2StarReviews",
"x1StarReviews"))],
controls = ctree_control(maxdepth = 3))
plot(avg_decisiontree)
#Cross validation:
set.seed(69)
indexing <- createDataPartition(products$Volume, p = 0.75, list = F)
trainSet <- products[indexing,]
testSet <- products[-indexing,]
form <- c("Volume ~ x4StarReviews + PositiveServiceReview",
"Volume ~ Avg_WghtStar + PositiveServiceReview")
models <- c("rf","knn", "svmLinear", "svmRadial","glm")
combined <- c()
cnames <- vector()
for (i in form){
for (j in models) {
model <- train(formula(i), data = trainSet, method = j, tuneLength = 3, metric = "MAE")
predictions <- predict(model, testSet)
results <- postResample(predictions, testSet$Volume)
combined <- cbind(results, combined)
cnames <- c(paste(i,j),cnames)
}
}
colnames(combined) <-cnames
min(combined[3,] )
kable(combined)
#Best model for MAE is rf with variables= Avg_WghtStar and PositiveServiceReview
#We create the new avg_wght star variable
newproducts$"Avg_WghtStar" <-  summary(lm_model)$coefficients[2]*newproducts$x4StarReviews +
summary(lm_model)$coefficients[3]*newproducts$x3StarReviews +
summary(lm_model)$coefficients[4]*newproducts$x2StarReviews +
summary(lm_model)$coefficients[5]*newproducts$x1StarReviews
rf_model <- train(Volume ~ Avg_WghtStar + PositiveServiceReview,
trainSet, tuneLength = 3, metric = "MAE")
newproducts$Volume <- predict(rf_model,newproducts)
products$Volume[products$Volume == 0] <- 1
Volume <- as.numeric(products$Volume)
ex_preds <- as.numeric(predict(rf_model,products))
ae_errors <- as.numeric(abs(ex_preds - products$Volume))
re_errors <- as.numeric(ae_errors/products$Volume)
errors_df <- as.data.frame(cbind(Volume,ex_preds,ae_errors,re_errors))
errors_df$ProductType <- ProductType
errors_df$ProductNum <- products$ProductNum
ggplot(errors_df, aes(x = Volume, y = re_errors, color = ProductType)) + geom_jitter() + ylab("Relative error") + ggtitle("Relative error vs Volume")
ggplot(errors_df, aes(x = Volume, y = ae_errors, color = ProductType)) + geom_jitter() + ylab("Absolute error") + ggtitle("Absolute error vs Volume")
ccols <- c("volume"="#f04546","pred"="#3591d1")
ggplot(errors_df, aes()) +geom_jitter(aes(x=ProductNum, y = ex_preds, color = "pred")) + geom_jitter(aes(x=ProductNum, y = Volume, color = "volume" )) +
geom_smooth(aes(x=ProductNum, y = ex_preds, color = "pred"),method = "loess",
se = F) +
geom_smooth(aes(x=ProductNum, y = Volume, color = "volume"),method = "loess",
se = F) + ylab("Volume")
filtered <- newproducts[which(newproducts$ProductType == "PC"|newproducts$ProductType == "Laptop"|
newproducts$ProductType == "Netbook"|
newproducts$ProductType == "Smartphone"), ]
finalresults <- filtered[,which(colnames(filtered) %in% c("ProductType","ProductNum","Volume"))]
finalresults$Volume <- round(finalresults$Volume,0)
finalresults$Volume <- as.integer(finalresults$Volume)
kable(finalresults, caption = "Volume of the new products")
source('~/Documents/Ubiqum/WEEK 6/TaskActual/Rscript/taskactual.R')
